#
msgid ""
msgstr ""
"Project-Id-Version: 1.0\n"
"POT-Creation-Date: 2022-06-17 13:05:07.276601\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"

#: game_config
msgid "De Morgan's game"
msgstr ""

#: intro
msgid ""
"# Captain De Morgan's logic Game\n"
"\n"
"## By Chris Birkbeck and Niki Kalaydzhieva\n"
"\n"
"Learn some logic yo\n"
"\n"
"# What is this game?\n"
"\n"
"This is a game to teach you some mathematical logic using Lean.\n"
"\n"
"Have fun!\n"
"\n"
"# Credits\n"
"\n"
"Some levels have been shamelessly borrowed from Kevin Buzzard's and Mohammad "
"Pedramfar's \n"
"\"Natural Numbers Game\" as well as  Kevin Buzzard's \"Formalizing "
"mathematics\" course at \n"
"Imperial College. \n"
"\n"
"\n"
msgstr ""

#: world_config
msgid "Tutorial"
msgstr ""

#: Tutorial level 1
msgid ""
"\n"
"#Logical statements \n"
"\n"
"You've seen logical statements already, these are statements that can be "
"true or false, for example: \n"
"\n"
"-The sum of two odd numbers is an even number\n"
"\n"
"-$36$ is divisible by $3$\n"
"\n"
"-$x > 2$\n"
"\n"
"\n"
"Lets see how one does this a computer, specifically in lean. In lean, "
"logical staments live in a \n"
"world called `Prop`. So for example if we write `P : Prop` we mean \"$P$ is "
"a logical statement.\" \n"
"Think of the `:` symbol as saying $P$  is a resident of `Prop` world (in "
"maths this would be denoted\n"
"by something like `P ∈ Prop`).\n"
"\n"
"#Truth Values\n"
"\n"
"The truth value of a logical statement (i.e. some `P : Prop`) is whether the "
"statement is true or \n"
"false.  For example, the truth value of the statement: \"For all integers $x "
"∈ ℤ$,  $0 ≤ x^2$\" \n"
"is *true* while  \"For all integers $x ∈ ℤ$,  $0 ≤ x^3$\" is *false*. \n"
"\n"
"In lean we assign truth values as follows: We first think of a proposition $P"
"$ as a set with \n"
"*at most* one element.  If this set is empty, then we say `P` is *false*. "
"Otherwise, if this set has \n"
"an element, lets call it $p$ (we will usually use upper case letters for "
"logical statements, \n"
"and lower case for their proofs), then this  statement is *true* and $p$ is "
"the proof. \n"
"\n"
"So to recap, if $P$ is the true/false statement (the statement of "
"proposition), and $p$ is its proof.\n"
"It's like thinking $P$ being the set and $p$ being the element. Just as "
"above, where we had \n"
"`P : Prop` to mean $P$  is a proposition, we write `p : P` to mean \"$p$ is "
"a proof of $P$\".\n"
"\n"
"The aim of this game is to learn how to manipulate logical statements and "
"their proofs. \n"
"Lets start with a super basic example of how a lemma looks like in lean.\n"
"\n"
"This is where the window on the right will come into play. If you delete the "
"*sorry* below, \n"
"on the right you will  see the following: \n"
"\n"
"```\n"
"P : Prop,\n"
"p : P,\n"
"⊢ P\n"
"```\n"
"\n"
"Here the first two lines are our assumptions and the thing after the `⊢` "
"symbol is what we are \n"
"being asked to prove. \n"
"\n"
"Now, in this game our \"moves\" or, as we call them in lean, *Tactics*, are "
"what will allow us to \n"
"manipulate our statement and produce proofs.\n"
"\n"
"The first tactic we will look at is called *exact* and what it does is, if "
"you need to prove a \n"
"statement $P$ and you have proof of it, say, `p: P`, then `exact p` will "
"prove it. \n"
"\n"
"Note that at the end of each line we write we need to have a comma `,` to "
"tell lean that this is the \n"
"end of our move. \n"
"\n"
"So if below you change the `sorry` for \"`exact p,`\" (don't forget the "
"comma!) you'll see that on the \n"
"right it will change to say `Proof complete!`. \n"
"\n"
msgstr ""

#: Tutorial level 1
msgid ""
"Lets try and prove that if $P$ is a logical stament (i.e. `P : Prop`) and $p"
"$ is a proof of $P$ \n"
"(i.e. `p : P`) then $P$ is true.\n"
msgstr ""

#: Tutorial level 1
msgid ""
"## Summary \n"
"If the goal is `⊢ P` then `exact p` will close the goal if\n"
"and only if `p` is a proof of `P` (i.e. `p : P`) \n"
"## Details\n"
"Say $P$, $Q$ and $R$ are logical staments\n"
"and the local context looks like this: \n"
"```\n"
"p : P,\n"
"h : P → Q,\n"
"j : Q → R\n"
"⊢ R\n"
"```\n"
"If you can spot how to make a term of type `R`, then you\n"
"can just make it and say you're done using the `exact` tactic\n"
"together with the formula you have spotted. For example the\n"
"above goal could be solved with\n"
"`exact j(h(p)),`\n"
"because $j(h(p))$ is easily checked to be a term of type $R$\n"
"(i.e., an element of the set $R$, or a proof of the proposition $R$).\n"
msgstr ""

#: Tutorial level 2
msgid "Now try the following one:\n"
msgstr ""

#: Tutorial level 3
msgid ""
"\n"
"#Combining logical statements\n"
"\n"
"Now, we can take these statements and create new ones. For example if we "
"have two statements \n"
"`P Q : Prop` we can write ` P → Q` to mean $P$ implies $Q$. Similarly, we "
"can write `¬P` for the \n"
"statement \"Not $P$\". \n"
"\n"
"Say we have the following lemma:\n"
"\n"
"```\n"
"P Q : Prop\n"
"h : P → Q\n"
"p : P\n"
"⊢ Q\n"
"```\n"
"This asks us to prove: If $P$ implies $Q$ (which is written ` P → Q`) and we "
"have a proof of $P$ \n"
"(i.e. we have `p : P`). Then $Q$ is true (i.e. we have a proof of `Q`). \n"
"\n"
"Here we have given the name $h$ to the implication ` P → Q`. We think of $h$ "
"as a map between \n"
"statements in `Prop` world. \n"
"\n"
"Now this lemma is asking us to take a proof of $P$ and turn it into a proof "
"of $Q$. Since we know \n"
"that $P$ implies $Q$ then we know that if $P$ is true then so is $Q$. So we "
"can use our map in \n"
"`Prop` world to transform our proof of $P$ into a proof of $Q$. \n"
"\n"
"If we write `exact h(p)` below we get what we want.\n"
"\n"
"Note that it has to be lower case $p$, since $P$ is the logical statement, "
"but what we want to \n"
"transform is the proof.\n"
"\n"
"\n"
"\n"
msgstr ""

#: Tutorial level 3
msgid ""
"If $P$ implies $Q$ (which is written ` P → Q`) and we have a proof of $P$ (i."
"e. we have `p : P`). \n"
"Then $Q$ is true (i.e. we have a proof of `Q`)\n"
msgstr ""

#: Tutorial level 4
msgid "Now try the following one: \n"
msgstr ""

#: world_config
msgid "Logical statements"
msgstr ""

#: Logical statements level 1
msgid "Tactics"
msgstr ""

#: Logical statements level 1
msgid ""
"\n"
"## Tactics for Level 1\n"
"\n"
"## The `intro` tactic.\n"
"\n"
"If your goal is\n"
"\n"
"```\n"
"⊢ P → Q\n"
"```\n"
"\n"
"then the tactic\n"
"\n"
"`intro hP,`\n"
"\n"
"will turn your tactic state into\n"
"\n"
"```\n"
"hP : P\n"
"⊢ Q\n"
"```\n"
"\n"
"Variant: `intros` can be used to introduce\n"
"more than one assumption at once. Don't forget\n"
"to name your hypotheses, e.g. `intros hP hQ` if your goal is `P → Q → "
"<something else>`.\n"
"\n"
"## The `exact` tactic (we have already seen this)\n"
"\n"
"If your tactic state is\n"
"\n"
"```\n"
"hP : P\n"
"⊢ P\n"
"```\n"
"\n"
"then the tactic\n"
"\n"
"`exact hP,`\n"
"\n"
"will close your goal.\n"
"\n"
"Note: `exact P` does not work. Don't confuse\n"
"the *statement* `P` with its *proof* `hP`.\n"
"\n"
"Variant: The `assumption` tactic closes a goal if its proof is any one of "
"the assumptions\n"
"in the tactic state. \n"
"\n"
"## The `apply` tactic\n"
"\n"
"If your tactic state is\n"
"\n"
"```\n"
"hPQ : P → Q\n"
"⊢ Q\n"
"```\n"
"\n"
"then the tactic\n"
"\n"
"`apply hPQ,`\n"
"\n"
"will change it to\n"
"\n"
"```\n"
"hPQ : P → Q\n"
"⊢ P\n"
"```\n"
"\n"
"The `apply` tactic is useful for *arguing backwards*. It reduces the goal to "
"a potentially easier \n"
"goal, without changing any hypotheses.\n"
"\n"
msgstr ""

#: Logical statements level 2
msgid "intro"
msgstr ""

#: Logical statements level 2
msgid ""
"\n"
"Lets look at an example that needs the `intro` tactic: \n"
"\n"
"If your goal is to prove `P → Q` (i.e. that $P\\implies Q$)\n"
"then `intro p`, meaning \"assume $p$ is a proof of $P$\", will make "
"progress.\n"
"To solve the goal below, you have to come up with a function from\n"
"`P` (thought of as the set of proofs of $P$!) to itself. Start with\n"
"`intro p,`\n"
"(i.e. \"let $p$ be a proof of $P$\") and note that our\n"
"local context now looks like this:\n"
"```\n"
"P : Prop,\n"
"p : P\n"
"⊢ P\n"
"```\n"
"Our job now is to construct a proof of $P$. But $p$ is a proof of $P$.\n"
"So\n"
"`exact p,`\n"
"will close the goal. Note that `exact P` will not work -- don't\n"
"confuse a true/false statement (which could be false!) with a proof.\n"
"We will stick with the convention of capital letters for propositions\n"
"and small letters for proofs.\n"
msgstr ""

#: Logical statements level 2
msgid "If $P$ is a proposition then $P\\implies P$.\n"
msgstr ""

#: Logical statements level 2
msgid ""
"\n"
"## The `intro` tactic.\n"
"\n"
"If your goal is\n"
"\n"
"```\n"
"⊢ P → Q\n"
"```\n"
"\n"
"then the tactic\n"
"\n"
"`intro hP,`\n"
"\n"
"will turn your tactic state into\n"
"\n"
"```\n"
"hP : P\n"
"⊢ Q\n"
"```\n"
"\n"
"Variant: `intros` can be used to introduce\n"
"more than one assumption at once. Don't forget\n"
"to name your hypotheses, e.g. `intros hP hQ` if your goal is `P → Q → "
"<something else>`.\n"
"\n"
msgstr ""

#: Logical statements level 3
msgid "apply tactic"
msgstr ""

#: Logical statements level 3
msgid ""
"Lets look at using the apply tactic:\n"
"\n"
"Here's an example we have already done, but try and do it using the apply "
"tactic:\n"
"\n"
msgstr ""

#: Logical statements level 3
msgid ""
"Lets try and prove that if `P` implies `Q` (which is written ` P → Q`) and "
"we have a proof of `P` \n"
"(i.e. we have `p : P`). Then `Q` is true (i.e. we have a proof of `Q`)\n"
msgstr ""

#: Logical statements level 3
msgid ""
"\n"
"## The `apply` tactic\n"
"\n"
"If your tactic state is\n"
"\n"
"```\n"
"hPQ : P → Q\n"
"⊢ Q\n"
"```\n"
"\n"
"then the tactic\n"
"\n"
"`apply hPQ,`\n"
"\n"
"will change it to\n"
"\n"
"```\n"
"hPQ : P → Q\n"
"⊢ P\n"
"```\n"
"\n"
"The `apply` tactic is useful for *arguing backwards*. It reduces the goal to "
"a potentially easier \n"
"goal, without changing any hypotheses.\n"
msgstr ""

#: Logical statements level 4
msgid "Assume `Q` is true. Prove that `P → Q`. \n"
msgstr ""

#: Logical statements level 5
msgid ""
"Note that implies `→` is not associative: in general `P → (Q → R)` and `(P → "
"Q) → R`\n"
"might not be equivalent. This is like subtraction on numbers -- in general\n"
"`a - (b - c)` and `(a - b) - c` might not be equal.\n"
"So if we write `P → Q → R` then we'd better know what this means.\n"
"The convention in Lean is that it means `P → (Q → R)`. If you think\n"
"about it, this means that to deduce `R` you will need to prove both `P`\n"
"and `Q`. \n"
"\n"
"In general to prove `P1 → P2 → P3 → ... Pn` you can assume\n"
"`P1`, `P2`,...,`P(n-1)` and then you have to prove `Pn`. \n"
"So the next level is asking you prove that `P → (Q → P)`.\n"
msgstr ""

#: Logical statements level 5
msgid "Prove $P$ implies $(P \\implies Q)$\n"
msgstr ""

#: Logical statements level 6
msgid ""
"If we know `P`, and we also know `P → Q`, we can deduce `Q`. \n"
"This is called \"Modus Ponens\" by logicians.\n"
msgstr ""

#: Logical statements level 7
msgid ""
"Lets show that implications are transitive. That is, if `P → Q` and `Q → R` "
"are true, then\n"
"so is `P → R`.\n"
msgstr ""

#: Logical statements level 8
msgid ""
"For the next one you might need to note the following:\n"
"\n"
"If we have the assumption `h : P → Q → R` with goal `⊢ R` and you `apply h`, "
"then you'll get\n"
"two goals! \n"
"\n"
"Note that tactics operate on only the first goal. So you'll have to first "
"prove the \n"
"first goal and then move onto the second. \n"
"\n"
"Tip:  If you have multiple goals and you want to work on one that isnt the "
"first one you can \n"
"write `sorry,` to skip a proving a goal (although you will need to come back "
"to it \n"
"eventually to complete the proof!)\n"
msgstr ""

#: Logical statements level 8
msgid ""
"Prove $(P \\implies Q \\implies R) \\implies ((P \\implies Q) \\implies (P "
"\\implies R)$\n"
msgstr ""

#: Logical statements level 9
msgid "Lets try some harder ones\n"
msgstr ""

#: Logical statements level 9
msgid "This isn't so bad\n"
msgstr ""

#: Logical statements level 10
msgid "More nested implications:\n"
msgstr ""

#: Logical statements level 11
msgid "Even more nested implications\n"
msgstr ""

#: Logical statements level 12
msgid "This is getting silly now\n"
msgstr ""

#: Logical statements level 13
msgid "How hard could it be?\n"
msgstr ""

#: Logical statements level 14
msgid "Boss fight 1"
msgstr ""

#: Logical statements level 14
msgid "Time for a boss fight!\n"
msgstr ""

#: world_config
msgid "Distributivity, Associativity and Absorption"
msgstr ""

#: Distributivity, Associativity and Absorption level 1
msgid "and what?"
msgstr ""

#: Distributivity, Associativity and Absorption level 1
msgid ""
"Lets now look at making some more complicated logical statements. Recall "
"that if we have two\n"
"statements $P,Q$ then we can form $P ∧ Q$ which is true iff both $P$ and $Q$ "
"are true.#check\n"
"\n"
"To help us with this, lets introduce some new tactics.\n"
"\n"
"\n"
"## Tactics for Level 2\n"
"\n"
"## The `split` tactic\n"
"\n"
"If your goal is an \"and\" goal:\n"
"\n"
"```\n"
"⊢ P ∧ Q\n"
"```\n"
"\n"
"then the `split` tactic will turn it\n"
"into *two* goals\n"
"\n"
"\n"
"```\n"
"⊢ P\n"
"```\n"
"\n"
"and\n"
"\n"
"```\n"
"⊢ Q\n"
"```\n"
"\n"
"It is best practice to indicate when you are working with two goals, either "
"by using squiggly \n"
"brackets like this:\n"
"\n"
"```\n"
"...\n"
"split,\n"
"{ working on P,\n"
"  end of proof of P },\n"
"{ working on Q,\n"
"  end of proof of Q },\n"
"```\n"
"\n"
"or by using indentation like this:\n"
"\n"
"```\n"
"split,\n"
"  working on P,\n"
"  end of proof of P,\n"
"working on Q,\n"
"...\n"
"```\n"
"\n"
"Moreover, if you have an iff `↔` then splitting it will give you two goals, "
"`→` and `←` to prove.\n"
"\n"
"## `left` and `right`\n"
"\n"
"If your goal is\n"
"\n"
"```\n"
"⊢ P ∨ Q\n"
"```\n"
"\n"
"then `left` changes the goal to `⊢ P`. The logic is that `P` implies `P ∨ "
"Q`\n"
"so we can `apply` this implication. Similarly `right` changes the goal to `⊢ "
"Q`\n"
"\n"
"## The `cases` tactic\n"
"\n"
"`cases` is a very general-purpose tactic for \"deconstructing\" hypotheses.\n"
"If `h` is a hypothesis which somehow \"bundles up\" two pieces of "
"information,\n"
"then `cases h with h1 h2` will make hypothesis `h` vanish and will replace "
"it\n"
"with the two \"components\" which made the proof of `h` in the first place.\n"
"An example of this occurring in logic sheet 4 is `h : P ∧ Q` which is a\n"
"bundling of a proof of `P` and a proof of `Q`.\n"
"\n"
"### Example\n"
"\n"
"If you have a hypothesis\n"
"\n"
"```\n"
"hPaQ : P ∧ Q\n"
"```\n"
"\n"
"then\n"
"\n"
"`cases hPaQ with hP hQ,`\n"
"\n"
"will delete `hPaQ` and replace it with\n"
"\n"
"```\n"
"hP : P\n"
"hQ : Q\n"
"```\n"
"\n"
"You can also use it for \"or's\". Specifically, if you have `h : P ∨ Q` then "
"`cases h` will\n"
"give you two goals, one where `P` is true and one where `Q` is true.\n"
"\n"
"\n"
msgstr ""

#: Distributivity, Associativity and Absorption level 1
msgid ""
"\n"
"If your goal is an \"and\" goal:\n"
"\n"
"```\n"
"⊢ P ∧ Q\n"
"```\n"
"\n"
"then the `split` tactic will turn it\n"
"into *two* goals\n"
"\n"
"\n"
"```\n"
"⊢ P\n"
"```\n"
"\n"
"and\n"
"\n"
"```\n"
"⊢ Q\n"
"```\n"
"Moreover, if you have an iff `↔` then splitting it will give you two goals, "
"`→` and `←` to prove.\n"
"\n"
msgstr ""

#: Distributivity, Associativity and Absorption level 1
msgid ""
"\n"
"If your goal is\n"
"\n"
"```\n"
"⊢ P ∨ Q\n"
"```\n"
"\n"
"then `left` changes the goal to `⊢ P`. The logic is that `P` implies `P ∨ "
"Q`\n"
"so we can `apply` this implication. Similarly `right` changes the goal to `⊢ "
"Q`\n"
"\n"
msgstr ""

#: Distributivity, Associativity and Absorption level 1
msgid ""
"\n"
"If you have a hypothesis\n"
"\n"
"```\n"
"hPaQ : P ∧ Q\n"
"```\n"
"\n"
"then\n"
"\n"
"`cases hPaQ with hP hQ,`\n"
"\n"
"will delete `hPaQ` and replace it with\n"
"\n"
"```\n"
"hP : P\n"
"hQ : Q\n"
"```\n"
"\n"
"You can also use it for \"or's\". Specifically, if you have `h : P ∨ Q` then "
"`cases h` will\n"
"give you two goals, one where `P` is true and one where `Q` is true.\n"
"\n"
msgstr ""

#: Distributivity, Associativity and Absorption level 2
msgid "Lets start with something easy. Lets prove that $P ∧ Q$ iff $Q ∧ P$\n"
msgstr ""

#: Distributivity, Associativity and Absorption level 2
msgid "Proving `∧` is symmetric\n"
msgstr ""

#: Distributivity, Associativity and Absorption level 3
msgid "Ok lets mix things up a bit:\n"
msgstr ""

#: Distributivity, Associativity and Absorption level 3
msgid ""
"Lets prove that $P ∧ Q$ implies that $(P \\implies R) \\implies (Q \\implies "
"R) \\implies R$ \n"
msgstr ""

#: Distributivity, Associativity and Absorption level 4
msgid "Let now show that `∧` is transitive\n"
msgstr ""

#: Distributivity, Associativity and Absorption level 4
msgid "Proving `∧` is transitive\n"
msgstr ""

#: Distributivity, Associativity and Absorption level 5
msgid "absorpsion laws pt 1"
msgstr ""

#: Distributivity, Associativity and Absorption level 5
msgid "Lets try and prove that $P ∧ (P ∨ Q)$ is equivalent to $P$\n"
msgstr ""

#: Distributivity, Associativity and Absorption level 6
msgid "absorpsion laws pt 2"
msgstr ""

#: Distributivity, Associativity and Absorption level 6
msgid "Lets try and prove that $P ∨ (P ∧ Q)$ is equivalent to $P$\n"
msgstr ""

#: Distributivity, Associativity and Absorption level 7
msgid "Associative laws pt 1"
msgstr ""

#: Distributivity, Associativity and Absorption level 7
msgid "Lets prove that $P ∧ (Q ∧ R)$ is equivalent to $(P ∧ Q) ∧ R$\n"
msgstr ""

#: Distributivity, Associativity and Absorption level 8
msgid "Associative laws pt 2"
msgstr ""

#: Distributivity, Associativity and Absorption level 8
msgid "Lets prove that $P ∨ (Q ∨ R)$ is equivalent to $(P ∨ Q) ∨ R$\n"
msgstr ""

#: Distributivity, Associativity and Absorption level 9 10
msgid "Distributive laws 1"
msgstr ""

#: Distributivity, Associativity and Absorption level 9
msgid "Lets prove that $P ∧ (Q ∨ R)$ is equivalent to $(P ∧ Q) ∨ (P ∧ R)$\n"
msgstr ""

#: Distributivity, Associativity and Absorption level 10
msgid "Lets prove that $P ∨ (Q ∧ R)$ is equivalent to $(P ∨ Q) ∧ (P ∨ R)$\n"
msgstr ""

#: world_config
msgid "Not logic"
msgstr ""

#: Not logic level 1
msgid ""
"There is a false proposition `false`, with no proof. It is\n"
"easy to check that $\\lnot Q$ is equivalent to $Q\\implies {\\tt false}$. "
"Lets call this\n"
"\n"
"`not_iff_imp_false (P : Prop) : ¬ P ↔ (P → false)`\n"
"\n"
msgstr ""

#: Not logic level 1
msgid ""
"\n"
"In order to use it, lets look at a new tactic.\n"
"\n"
"## The `rw` tactic\n"
"\n"
"The `rw` tactic or ``rewrite`` is a tactic that allows you to substitute in "
"things. For example, if we have the\n"
"assumption `h: P ↔ Q`, then `rw h` will replace the `P`'s in the goal with "
"`Q`'s. If instead you would like to \n"
"turn all of the `Q`'s in your goal to `P`'s then using `rw ←h` will do this. "
"(To get the `←` arrow, type `\\l`)\n"
"\n"
"\n"
"(This also works for equalities, but we won't see them in this game).\n"
"\n"
"\n"
"Using `rw` and `not_iff_imp_false`, try to prove the following:\n"
"\n"
msgstr ""

#: Not logic level 1
msgid " Start by using `rw not_iff_imp_false,` and see what changes.\n"
msgstr ""

#: Not logic level 1
msgid "using rw"
msgstr ""

#: Not logic level 1
msgid ""
"If $P$ and $Q$ are propositions, and $P\\implies Q$, then\n"
"$\\lnot Q\\implies \\lnot P$. \n"
msgstr ""

#: Not logic level 1
msgid ""
"\n"
"\n"
msgstr ""

#: Not logic level 1
msgid ""
"\n"
"The `rw` tactic or ``rewrite`` is a tactic that allows you to substitute in "
"things. For example, if we have the\n"
"assumption `h: P ↔ Q`, then `rw h` will replace the `P`'s in the goal with "
"`Q`'s. If instead you would like to \n"
"turn all of the `Q`'s in your goal to `P`'s then using `rw ←h` will do this. "
"(To get the `←` arrow, type `\\l`)\n"
"\n"
msgstr ""

#: Not logic level 2
msgid ""
"##  `exfalso` and proof by contradiction. \n"
"It's certainly true that $P\\land(\\lnot P)\\implies Q$ for any propositions "
"$P$\n"
"and $Q$, because the left hand side of the implication is false. But how do\n"
"we prove that `false` implies any proposition $Q$? A cheap way of doing it "
"in\n"
"Lean is using the `exfalso` tactic, which changes any goal at all to "
"`false`. \n"
"You might think this is a step backwards, but if you have a hypothesis `h : "
"¬ P`\n"
"then after `rw not_iff_imp_false at h,` you can `apply h,` to make "
"progress. \n"
"Try solving this level using `exfalso.\n"
msgstr ""

#: Not logic level 2
msgid ""
"If $P$ and $Q$ are true/false statements, then\n"
"$$(P\\land(\\lnot P))\\implies Q.$$\n"
msgstr ""

#: Not logic level 2
msgid "This changes any goal to `false`.\n"
msgstr ""

#: Not logic level 3
msgid ""
"We proved earlier that `(P → Q) → (¬ Q → ¬ P)`. The converse,\n"
"that `(¬ Q → ¬ P) → (P → Q)` is certainly true, but trying to prove\n"
"it using what we've learnt so far is impossible (because it is not provable "
"in\n"
"constructive logic). For example, after\n"
"```\n"
"intro h,\n"
"intro p,\n"
"repeat {rw not_iff_imp_false at h},\n"
"```\n"
"in the below, you are left with\n"
"```\n"
"P Q : Prop,\n"
"h : (Q → false) → P → false\n"
"p : P\n"
"⊢ Q\n"
"```\n"
"The tools you have are not sufficient to continue. But you can just\n"
"prove this, and any other basic lemmas of this form like `¬ ¬ P → P`,\n"
"using the `by_cases` tactic. Instead of starting with all the `intro`s,\n"
"try this instead:\n"
"`by_cases p : P; by_cases q : Q,`\n"
"**Note the semicolon**! It means \"do the next tactic to all the goals, not "
"just the top one\".\n"
"After it, there are four goals, one for each of the four possibilities "
"PQ=TT, TF, FT, FF.\n"
"You can see that `p` is a proof of `P` in some of the goals, and a proof of "
"`¬ P` in others.\n"
"Similar comments apply to `q`. \n"
"\n"
"Note that using `by_cases` is the same as doing a truth table for the result "
"you want to prove.\n"
"\n"
"You may also want to use some of the previous results we have used, for "
"example the `contra` lemma we proved\n"
"in the previous level. To use this try something like `apply contra P Q`. "
"Alternatively, there is a tactic \n"
"`contradiction` that will look at your assumptions and try and close the "
"goal for you.\n"
"\n"
"\n"
msgstr ""

#: Not logic level 3
msgid ""
"Along with `by_cases p : P; by_cases q : Q,` you may also want to use `apply "
"contra P false`\n"
msgstr ""

#: Not logic level 3
msgid "Hint"
msgstr ""

#: Not logic level 3
msgid ""
"If $P$ and $Q$ are true/false statements, then\n"
"$$(\\lnot Q\\implies \\lnot P)\\implies(P\\implies Q).$$ \n"
msgstr ""

#: Not logic level 3
msgid ""
"This approach assumed that `P ∨ ¬ P` was true; the `by_cases` tactic just "
"does `cases` on\n"
"this result. This is called the law of the excluded middle, and it cannot be "
"proved just\n"
"using tactics such as `intro` and `apply`.\n"
msgstr ""

#: Not logic level 3
msgid ""
"\n"
"All propositional logic problems can in theory be solved by just throwing a "
"truth table at them. \n"
"The ``by_cases`` tactic is a simple truth table tactic: ``by_cases P`` turns "
"one goal into two goals, \n"
"with ``P`` is assumed in the first, and ``Â¬P`` in the second.\n"
"\n"
"Examples\n"
"--------\n"
"\n"
"1) If ``P`` is a proposition, then ``by_cases P`` turns your goal into two "
"goals, \n"
"and in each of your new tactic states you have one extra hypothesis. \n"
"In the first one you have a new hypothesis ``h : P`` and in the second you "
"have a new hypothesis ``h : ¬P``.\n"
"\n"
"2) If you already have a hypothesis ``h`` then this can get a bit "
"confusing, \n"
"so you can also do ``by_cases hP : P``; then your new hypotheses will be "
"``hP : P`` and ``hP : ¬P``.\n"
msgstr ""

#: world_config
msgid "De Morgan's laws"
msgstr ""

#: De Morgan's laws level 1
msgid "De Morgan's laws, First Boss"
msgstr ""

#: De Morgan's laws level 1
msgid ""
"Ok time to use everything we have leaned to prove the first of De Morgans "
"laws.\n"
"\n"
msgstr ""

#: De Morgan's laws level 1
msgid ""
"\n"
"You can do this only using `split`, `intro`, `apply`, `left`, `right`.\n"
"\n"
msgstr ""

#: De Morgan's laws level 1
msgid "First hint"
msgstr ""

#: De Morgan's laws level 1
msgid ""
"\n"
"Note that if you have a goal `¬P` then `intro h` will turn your goal into "
"`false`.\n"
"\n"
msgstr ""

#: De Morgan's laws level 1
msgid "Second hint"
msgstr ""

#: De Morgan's laws level 1
msgid ""
"\n"
"Note that if you have a goal `false` and an assumption `h : ¬P`, then `apply "
"h` will turn your goal into `P`.\n"
"\n"
msgstr ""

#: De Morgan's laws level 1
msgid "Last hint"
msgstr ""

#: De Morgan's laws level 1
msgid "Not $P$ or $Q$ is equivalent to $¬ P$ and $¬Q$.\n"
msgstr ""

#: De Morgan's laws level 2
msgid "De Morgan's laws, Final Boss"
msgstr ""

#: De Morgan's laws level 2
msgid "Not $P$ and $Q$ is equivalent to $¬ P$ or $¬Q$.\n"
msgstr ""
