#
msgid ""
msgstr ""
"Project-Id-Version: 1.0\n"
"POT-Creation-Date: 2022-06-15 19:31:29.021027\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"

#: game_config
msgid "Niki's Logic"
msgstr ""

#: intro
msgid ""
"# Captain de Morgan's logic Game\n"
"\n"
"## By UCL\n"
"\n"
"Learn some logic yo\n"
"\n"
"# What is this game?\n"
"\n"
"This is a game to teach you some mathematical logic using Lean.\n"
"\n"
"Have fun!\n"
"\n"
"# Credits\n"
"\n"
"Some levels have been shamelessly borrowed from Kevin Buzzard's and Mohammad "
"Pedramfar's \n"
"\"Natural Numbers Game\" as well as  Kevin Buzzard's \"Formalizing "
"mathematics\" course at \n"
"Imperial College. \n"
"\n"
"\n"
msgstr ""

#: world_config
msgid "Tutorial"
msgstr ""

#: Tutorial level 1
msgid ""
"\n"
"#Logical statements \n"
"\n"
"You've seen logical statements already, these are statements that can be "
"true or false, for example: \n"
"\n"
"-The sum of two odd numbers is an even number\n"
"\n"
"-$36$ is divisible by $3$\n"
"\n"
"-$x > 2$\n"
"\n"
"\n"
"Lets see how one does this a computer, specifically in lean. In lean, "
"logical staments live in a \n"
"world called `Prop`. So for example if we write `P : Prop` we mean \"$P$ is "
"a logical statement.\" \n"
"Think of the `:` symbol as saying $P$  is a resident of `Prop` world (in "
"maths this would be denoted\n"
"by something like `P ∈ Prop`).\n"
"\n"
"#Truth Values\n"
"\n"
"The truth value of a logical statement (i.e. some `P : Prop`) is whether the "
"statement is true or \n"
"false.  For example, the truth value of the statement: \"For all integers $x "
"∈ ℤ$,  $0 ≤ x^2$\" \n"
"is *true* while  \"For all integers $x ∈ ℤ$,  $0 ≤ x^3$\" is *false*. \n"
"\n"
"In lean we assign truth values as follows: We first think of a proposition $P"
"$ as a set with \n"
"*at most* one element.  If this set is empty, then we say `P` is *false*. "
"Otherwise, if this set has \n"
"an element, lets call it $p$ (we will usually use upper case letters for "
"logical statements, \n"
"and lower case for their proofs), then this  statement is *true* and $p$ is "
"the proof. \n"
"\n"
"So to recap, if $P$ is the true/false statement (the statement of "
"proposition), and $p$ is its proof.\n"
"It's like thinking $P$ being the set and $p$ being the element. Just as "
"above, where we had \n"
"`P : Prop` to mean $P$  is a proposition, we write `p : P` to mean \"$p$ is "
"a proof of $P$\".\n"
"\n"
"The aim of this game is to learn how to manipulate logical statements and "
"their proofs. \n"
"Lets start with a super basic example of how a lemma looks like in lean.\n"
"\n"
"This is where the window on the right will come into play. If you delete the "
"*sorry* below, \n"
"on the right you will  see the following: \n"
"\n"
"```\n"
"P : Prop,\n"
"p : P,\n"
"⊢ P\n"
"```\n"
"\n"
"Here the first two lines are our assumptions and the thing after the `⊢` "
"symbol is what we are \n"
"being asked to prove. \n"
"\n"
"Now, in this game our \"moves\" or, as we call them in lean, *Tactics*, are "
"what will allow us to \n"
"manipulate our statement and produce proofs.\n"
"\n"
"The first tactic we will look at is called *exact* and what it does is, if "
"you need to prove a \n"
"statement $P$ and you have proof of it, say, `p: P`, then `exact p` will "
"prove it. \n"
"\n"
"Note that at the end of each line we write we need to have a comma `,` to "
"tell lean that this is the \n"
"end of our move. \n"
"\n"
"So if below you change the `sorry` for \"`exact p,`\" (don't forget the "
"comma!) you'll see that on the \n"
"right it will change to say `Proof complete!`. \n"
"\n"
msgstr ""

#: Tutorial level 1
msgid ""
"Lets try and prove that if $P$ is a logical stament (i.e. `P : Prop`) and $p"
"$ is a proof of $P$ \n"
"(i.e. `p : P`) then $P$ is true.\n"
msgstr ""

#: Tutorial level 1
msgid ""
"## Summary \n"
"If the goal is `⊢ P` then `exact p` will close the goal if\n"
"and only if `p` is a proof of `P` (i.e. `p : P`) \n"
"## Details\n"
"Say $P$, $Q$ and $R$ are logical staments\n"
"and the local context looks like this: \n"
"```\n"
"p : P,\n"
"h : P → Q,\n"
"j : Q → R\n"
"⊢ R\n"
"```\n"
"If you can spot how to make a term of type `R`, then you\n"
"can just make it and say you're done using the `exact` tactic\n"
"together with the formula you have spotted. For example the\n"
"above goal could be solved with\n"
"`exact j(h(p)),`\n"
"because $j(h(p))$ is easily checked to be a term of type $R$\n"
"(i.e., an element of the set $R$, or a proof of the proposition $R$).\n"
msgstr ""

#: Tutorial level 2
msgid "Now try the following one:\n"
msgstr ""

#: Tutorial level 3
msgid ""
"\n"
"#Combining logical statements\n"
"\n"
"Now, we can take these statements and create new ones. For example if we "
"have two statements \n"
"`P Q : Prop` we can write ` P → Q` to mean $P$ implies $Q$. Similarly, we "
"can write `¬P` for the \n"
"statement \"Not $P$\". \n"
"\n"
"Say we have the following lemma:\n"
"\n"
"```\n"
"P Q : Prop\n"
"h : P → Q\n"
"p : P\n"
"⊢ Q\n"
"```\n"
"This asks us to prove: If $P$ implies $Q$ (which is written ` P → Q`) and we "
"have a proof of $P$ \n"
"(i.e. we have `p : P`). Then $Q$ is true (i.e. we have a proof of `Q`). \n"
"\n"
"Here we have given the name $h$ to the implication ` P → Q`. We think of $h$ "
"as a map between \n"
"statements in `Prop` world. \n"
"\n"
"Now this lemma is asking us to take a proof of $P$ and turn it into a proof "
"of $Q$. Since we know \n"
"that $P$ implies $Q$ then we know that if $P$ is true then so is $Q$. So we "
"can use our map in \n"
"`Prop` world to transform our proof of $P$ into a proof of $Q$. \n"
"\n"
"If we write `exact h(p)` below we get what we want.\n"
"\n"
"Note that it has to be lower case $p$, since $P$ is the logical statement, "
"but what we want to \n"
"transform is the proof.\n"
"\n"
"\n"
"\n"
msgstr ""

#: Tutorial level 3
msgid ""
"If $P$ implies $Q$ (which is written ` P → Q`) and we have a proof of $P$ (i."
"e. we have `p : P`). \n"
"Then $Q$ is true (i.e. we have a proof of `Q`)\n"
msgstr ""

#: Tutorial level 4
msgid "Now try the following one: \n"
msgstr ""

#: world_config
msgid "Logical statements"
msgstr ""

#: Logical statements level 1
msgid "Tactics"
msgstr ""

#: Logical statements level 1
msgid ""
"\n"
"## Tactics for Level 1\n"
"\n"
"## The `intro` tactic.\n"
"\n"
"If your goal is\n"
"\n"
"```\n"
"⊢ P → Q\n"
"```\n"
"\n"
"then the tactic\n"
"\n"
"`intro hP,`\n"
"\n"
"will turn your tactic state into\n"
"\n"
"```\n"
"hP : P\n"
"⊢ Q\n"
"```\n"
"\n"
"Variant: `intros` can be used to introduce\n"
"more than one assumption at once. Don't forget\n"
"to name your hypotheses, e.g. `intros hP hQ` if your goal is `P → Q → "
"<something else>`.\n"
"\n"
"## The `exact` tactic (we have already seen this)\n"
"\n"
"If your tactic state is\n"
"\n"
"```\n"
"hP : P\n"
"⊢ P\n"
"```\n"
"\n"
"then the tactic\n"
"\n"
"`exact hP,`\n"
"\n"
"will close your goal.\n"
"\n"
"Note: `exact P` does not work. Don't confuse\n"
"the *statement* `P` with its *proof* `hP`.\n"
"\n"
"Variant: The `assumption` tactic closes a goal if its proof is any one of "
"the assumptions\n"
"in the tactic state. \n"
"\n"
"## The `apply` tactic\n"
"\n"
"If your tactic state is\n"
"\n"
"```\n"
"hPQ : P → Q\n"
"⊢ Q\n"
"```\n"
"\n"
"then the tactic\n"
"\n"
"`apply hPQ,`\n"
"\n"
"will change it to\n"
"\n"
"```\n"
"hPQ : P → Q\n"
"⊢ P\n"
"```\n"
"\n"
"The `apply` tactic is useful for *arguing backwards*. It reduces the goal to "
"a potentially easier \n"
"goal, without changing any hypotheses.\n"
"\n"
msgstr ""

#: Logical statements level 2
msgid "intro"
msgstr ""

#: Logical statements level 2
msgid ""
"\n"
"Lets look at an example that needs the `intro` tactic: \n"
"\n"
"If your goal is to prove `P → Q` (i.e. that $P\\implies Q$)\n"
"then `intro p`, meaning \"assume $p$ is a proof of $P$\", will make "
"progress.\n"
"To solve the goal below, you have to come up with a function from\n"
"`P` (thought of as the set of proofs of $P$!) to itself. Start with\n"
"`intro p,`\n"
"(i.e. \"let $p$ be a proof of $P$\") and note that our\n"
"local context now looks like this:\n"
"```\n"
"P : Prop,\n"
"p : P\n"
"⊢ P\n"
"```\n"
"Our job now is to construct a proof of $P$. But $p$ is a proof of $P$.\n"
"So\n"
"`exact p,`\n"
"will close the goal. Note that `exact P` will not work -- don't\n"
"confuse a true/false statement (which could be false!) with a proof.\n"
"We will stick with the convention of capital letters for propositions\n"
"and small letters for proofs.\n"
msgstr ""

#: Logical statements level 2
msgid "If $P$ is a proposition then $P\\implies P$.\n"
msgstr ""

#: Logical statements level 2
msgid ""
"\n"
"## The `intro` tactic.\n"
"\n"
"If your goal is\n"
"\n"
"```\n"
"⊢ P → Q\n"
"```\n"
"\n"
"then the tactic\n"
"\n"
"`intro hP,`\n"
"\n"
"will turn your tactic state into\n"
"\n"
"```\n"
"hP : P\n"
"⊢ Q\n"
"```\n"
"\n"
"Variant: `intros` can be used to introduce\n"
"more than one assumption at once. Don't forget\n"
"to name your hypotheses, e.g. `intros hP hQ` if your goal is `P → Q → "
"<something else>`.\n"
"\n"
msgstr ""

#: Logical statements level 3
msgid "apply tactic"
msgstr ""

#: Logical statements level 3
msgid ""
"Lets look at using the apply tactic:\n"
"\n"
"Here's an example we have already done, but try and do it using the apply "
"tactic:\n"
"\n"
msgstr ""

#: Logical statements level 3
msgid ""
"Lets try and prove that if `P` implies `Q` (which is written ` P → Q`) and "
"we have a proof of `P` \n"
"(i.e. we have `p : P`). Then `Q` is true (i.e. we have a proof of `Q`)\n"
msgstr ""

#: Logical statements level 3
msgid ""
"\n"
"## The `apply` tactic\n"
"\n"
"If your tactic state is\n"
"\n"
"```\n"
"hPQ : P → Q\n"
"⊢ Q\n"
"```\n"
"\n"
"then the tactic\n"
"\n"
"`apply hPQ,`\n"
"\n"
"will change it to\n"
"\n"
"```\n"
"hPQ : P → Q\n"
"⊢ P\n"
"```\n"
"\n"
"The `apply` tactic is useful for *arguing backwards*. It reduces the goal to "
"a potentially easier \n"
"goal, without changing any hypotheses.\n"
msgstr ""

#: Logical statements level 4
msgid "Assume `Q` is true. Prove that `P → Q`. \n"
msgstr ""

#: Logical statements level 5
msgid ""
"Note that implies `→` is not associative: in general `P → (Q → R)` and `(P → "
"Q) → R`\n"
"might not be equivalent. This is like subtraction on numbers -- in general\n"
"`a - (b - c)` and `(a - b) - c` might not be equal.\n"
"So if we write `P → Q → R` then we'd better know what this means.\n"
"The convention in Lean is that it means `P → (Q → R)`. If you think\n"
"about it, this means that to deduce `R` you will need to prove both `P`\n"
"and `Q`. \n"
"\n"
"In general to prove `P1 → P2 → P3 → ... Pn` you can assume\n"
"`P1`, `P2`,...,`P(n-1)` and then you have to prove `Pn`. \n"
"So the next level is asking you prove that `P → (Q → P)`.\n"
msgstr ""

#: Logical statements level 5
msgid "Prove $P$ implies $(P \\implies Q)$\n"
msgstr ""

#: Logical statements level 6
msgid ""
"If we know `P`, and we also know `P → Q`, we can deduce `Q`. \n"
"This is called \"Modus Ponens\" by logicians.\n"
msgstr ""

#: Logical statements level 7
msgid ""
"Lets show that implications are transitive. That is, if `P → Q` and `Q → R` "
"are true, then\n"
"so is `P → R`.\n"
msgstr ""

#: Logical statements level 8
msgid ""
"For the next one you might need to note the following:\n"
"\n"
"If we have the assumption `h : P → Q → R` with goal `⊢ R` and you `apply h`, "
"then you'll get\n"
"two goals! \n"
"\n"
"Note that tactics operate on only the first goal. So you'll have to first "
"prove the \n"
"first goal and then move onto the second. \n"
"\n"
"Tip:  If you have multiple goals and you want to work on one that isnt the "
"first one you can \n"
"write `sorry,` to skip a proving a goal (although you will need to come back "
"to it \n"
"eventually to complete the proof!)\n"
msgstr ""

#: Logical statements level 8
msgid ""
"Prove $(P \\implies Q \\implies R) \\implies ((P \\implies Q) \\implies (P "
"\\implies R)$\n"
msgstr ""

#: Logical statements level 9
msgid "Lets try some harder ones\n"
msgstr ""

#: Logical statements level 9
msgid "This isn't so bad\n"
msgstr ""

#: Logical statements level 10
msgid "More nested implications:\n"
msgstr ""

#: Logical statements level 11
msgid "Even more nested implications\n"
msgstr ""

#: Logical statements level 12
msgid "This is getting silly now\n"
msgstr ""

#: Logical statements level 13
msgid "How hard could it be?\n"
msgstr ""

#: Logical statements level 14
msgid "Boss fight 1"
msgstr ""

#: Logical statements level 14
msgid "Time for a boss fight!\n"
msgstr ""
